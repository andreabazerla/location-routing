model "Location Routing"
	uses "mmxprs", "mmive"

  	version 1.0.0

  	setparam("XPRS_VERBOSE", true)

	forward function Connessi:integer
	forward procedure azzera_visto
	forward procedure visita(n:integer)

	forward procedure draw_locations
  	forward procedure draw_customers
  	forward procedure draw_edges

  	declarations
    	locations_number: integer
    	customers_number: integer
    	points_number: integer
    	depots_capacity: integer
    end-declarations

    locations_number := 3
  	customers_number := 10

	! Punti considerati come di inizio e di fine
  	points_number := locations_number*2 + customers_number

  	depots_capacity := 15
  	customer_max_demand := 10
  	depot_max_cost := 10
  	point_max_range := 100

  	LOCATIONS_NUMBER := 1..locations_number
  	CUSTOMERS_NUMBER := 1..customers_number

  	POINTS_NUMBER := 1..points_number

  	declarations
		LOCATIONS: array(LOCATIONS_NUMBER) of array(1..3) of integer
		LOCATIONS_START: array(LOCATIONS_NUMBER) of array(1..3) of integer
		LOCATIONS_END: array(locations_number+1..locations_number*2) of array(1..3) of integer
		LOCATIONS_START_END: array(1..locations_number*2) of array(1..3) of integer

		CUSTOMERS: array(CUSTOMERS_NUMBER) of array(1..3) of integer

		POINTS: array(POINTS_NUMBER) of array(1..3) of integer
		visto: array(POINTS_NUMBER) of integer

		build_depot: array(1..locations_number*2) of mpvar

		DISTANCES: array(POINTS_NUMBER, POINTS_NUMBER) of real
		edge_exists: array(POINTS_NUMBER, POINTS_NUMBER) of mpvar
		
		customer_depot: array(CUSTOMERS_NUMBER, LOCATIONS_NUMBER) of mpvar

		Objective: linctr
  	end-declarations

	forall(i in 1..locations_number*2) build_depot(i) is_binary
	forall(i in POINTS_NUMBER, j in POINTS_NUMBER) edge_exists(i,j) is_binary
	forall(i in CUSTOMERS_NUMBER, j in LOCATIONS_NUMBER) customer_depot(i,j) is_binary

!INITIALIZATION OF ARRAYS-----------------------------------------------------

	contatore := 1
  	forall(i in LOCATIONS_NUMBER) do
		LOCATIONS(i,1) := integer(round((point_max_range*random)))
		LOCATIONS(i,2) := integer(round((point_max_range*random)))
		LOCATIONS(i,3) := integer(round((depot_max_cost*random)+0.5))
	end-do
		
	forall(i in LOCATIONS_NUMBER) do
		LOCATIONS_START(i,1) := LOCATIONS(i,1)
		LOCATIONS_START(i,2) := LOCATIONS(i,2)
		LOCATIONS_START(i,3) := LOCATIONS(i,3)
		contatore := i
	end-do
  	forall(i in LOCATIONS_NUMBER) do
  		LOCATIONS_END(contatore+i,1) := LOCATIONS(i,1)
		LOCATIONS_END(contatore+i,2) := LOCATIONS(i,2)
		LOCATIONS_END(contatore+i,3) := LOCATIONS(i,3)
	end-do
  	
  	writeln(LOCATIONS)
  	writeln(LOCATIONS_START)
  	writeln(LOCATIONS_END)
  	
  	forall(i in LOCATIONS_NUMBER) do
  		LOCATIONS_START_END(i,1) := LOCATIONS_START(i,1)
  		LOCATIONS_START_END(i,2) := LOCATIONS_START(i,2)
  		LOCATIONS_START_END(i,3) := LOCATIONS_START(i,3)
  		contatore := i
  	end-do
  	forall(i in LOCATIONS_NUMBER) do
  		LOCATIONS_START_END(contatore+i,1) := LOCATIONS_END(contatore+i,1)
  		LOCATIONS_START_END(contatore+i,2) := LOCATIONS_END(contatore+i,2)
  		LOCATIONS_START_END(contatore+i,3) := LOCATIONS_END(contatore+i,3)
  	end-do
  	writeln(LOCATIONS_START_END)

  	forall(i in CUSTOMERS_NUMBER) do		
		CUSTOMERS(i,1) := integer(round((point_max_range*random)))
		CUSTOMERS(i,2) := integer(round((point_max_range*random)))
		CUSTOMERS(i,3) := integer(round((customer_max_demand*random)+0.5))
  	end-do
  	writeln(CUSTOMERS)

	contatore := 0
	forall(i in LOCATIONS_NUMBER) do
		POINTS(i,1) := LOCATIONS(i,1)
		POINTS(i,2) := LOCATIONS(i,2)
		POINTS(i,3) := LOCATIONS(i,3)
		
		POINTS(i+locations_number,1) := LOCATIONS(i,1)
		POINTS(i+locations_number,2) := LOCATIONS(i,2)
		POINTS(i+locations_number,3) := LOCATIONS(i,3)
		
		contatore := i*2
	end-do

	forall(i in CUSTOMERS_NUMBER) do
		POINTS(contatore+i,1) := CUSTOMERS(i,1)
		POINTS(contatore+i,2) := CUSTOMERS(i,2)
		POINTS(contatore+i,3) := CUSTOMERS(i,3)
	end-do
	writeln(POINTS)

	forall(i in POINTS_NUMBER) do
		forall(j in POINTS_NUMBER) do
			if (i<=locations_number*2 and j<=locations_number*2) then
				DISTANCE(i,j) := 0.0
			else
				DISTANCE(i,j) := sqrt((POINTS(j,1)-POINTS(i,1))^2 + (POINTS(j,2)-POINTS(i,2))^2)
			end-if
			write(strfmt(DISTANCE(i,j), 2, 2), "\t")
		end-do
		write("\n")
	end-do

!VINCOLI DEL MODELLO-----------------------------------------------------------
	
	! Vincolo di capacità
	forall(j in LOCATIONS_NUMBER)
		sum(i in CUSTOMERS_NUMBER) CUSTOMERS(i,3) * customer_depot(i,j) <= depots_capacity * build_depot(j)
	
	! No archi su loro stessi
	sum(i in POINTS_NUMBER, j in POINTS_NUMBER | i=j) edge_exists(i,j) = 0
	
	! Uno ed uno solo arco entrante ed uscente
	forall(i in POINTS_NUMBER) do
		sum(j in POINTS_NUMBER) edge_exists(i,j) = 1
		sum(j in POINTS_NUMBER) edge_exists(j,i) = 1
	end-do
	
	! Dopo un magazzino end ci deve essere al massimo un arco verso un magazzino start
	forall(i in locations_number+1..locations_number*2)
		sum(j in 1..locations_number | i<>j) edge_exists(i,j) <= 1
	
	! Dopo ogni magazzino start aperto ci deve essere un cliente	
	forall(i in LOCATIONS_NUMBER)
		sum(j in locations_number*2..points_number) edge_exists(i,j) = build_depot(i)
		
	! Ogni magazzino end se costruito viene raggiunto solo da un cliente
	forall(j in locations_number+1..locations_number*2)
		sum(i in 1..customers_number) edge_exists(i,j) = build_depot(j)
	
	! Se è un magazzino di start è aperto allora lo è anche il suo end
	forall(i in LOCATIONS_NUMBER)
		build_depot(i+locations_number) = build_depot(i)
		
	! Ogni coppia di nodi è connessa da un solo arco (non funziona)
	!forall(i in POINTS_NUMBER)
	!	sum(j in POINTS_NUMBER) (edge_exists(i,j) + edge_exists(j,i)) <= 1
	
!FUNZIONE OBIETTIVO------------------------------------------------------------

  	Objective := sum(i in LOCATIONS_NUMBER) LOCATIONS(i,3) * build_depot(i) + sum(i in POINTS_NUMBER, j in POINTS_NUMBER) DISTANCE(i,j) * edge_exists(i,j)

	minimize(Objective)
	writeln("\nObjective = ", getobjval, "\n")

	azzera_visto
	
	forall(i in LOCATIONS_NUMBER) do
		if(getsol(build_depot(i))=1) then
			visita(i)
			break
		end-if
	end-do
	
	iter := 0
	n_nodi := customers_number + sum(i in 1..locations_number*2) getsol(build_depot(i))
	while(Connessi < n_nodi and iter < 50) do
		n_nodi_sottociclo := Connessi
		
		! VIncolo del cutset
		sum(i,j in POINTS_NUMBER | exists(edge_exists(i,j)) and (visto(i)+visto(j)=1)) edge_exists(i,j) >= 2
		
		iter := iter + 1
		minimize(Objective)
		writeln("\nObjective = ", getobjval, "\n")
		
		azzera_visto
		
		forall(i in LOCATIONS_NUMBER) do
			if(getsol(build_depot(i))=1) then
				visita(i)
				break
			end-if
		end-do
		
		n_nodi := customers_number + sum(i in 1..locations_number*2) getsol(build_depot(i))
	end-do

  	!minimize(XPRS_LIN, Objective)
  	!writeln("\nObjective linear = ", getobjval, "\n")

	forall(i in 1..locations_number*2) do
		write(getsol(build_depot(i)))
		write(' ')
	end-do
	
	writeln("\n")
	
	forall(i in POINTS_NUMBER) do
		forall(j in POINTS_NUMBER) do
			write(getsol(edge_exists(i,j)))
			write(' ')
		end-do
		writeln('')
	end-do

  	draw_locations
  	draw_customers
  	
  	draw_edges

!FUNZIONI---------------------------------------------------------------------

	function Connessi:integer
		returned := sum(i in POINTS_NUMBER) visto(i)
	end-function

!PROCEDURE--------------------------------------------------------------------
	
	procedure azzera_visto
		forall(i in POINTS_NUMBER)
			visto(i) := 0
	end-procedure
	
	procedure visita(n:integer)
		if(visto(n)<>1) then
			visto(n) := 1
			forall(m in POINTS_NUMBER | n<m and (getsol(edge_exists(n,m))<>0))
				visita(m)
			forall(m in POINTS_NUMBER | n>m and (getsol(edge_exists(m,n))<>0))
				visita(m)
		end-if
	end-procedure
	
	procedure draw_locations
		IVEerase
		IVEzoom(0,0,point_max_range,point_max_range)
		locations_plot := IVEaddplot("Locations", IVE_RED)
		forall(i in LOCATIONS_NUMBER) IVEdrawpoint(locations_plot, LOCATIONS(i,1), LOCATIONS(i,2));
		forall(i in LOCATIONS_NUMBER) IVEdrawlabel(locations_plot, LOCATIONS(i,1), LOCATIONS(i,2), strfmt(LOCATIONS(i,3),2));
		!forall(i in LOCATIONS_NUMBER) IVEdrawlabel(locations_plot, LOCATIONS(i,1), LOCATIONS(i,2), strfmt(i,2));
	end-procedure

	procedure draw_customers
		IVEzoom(0,0,point_max_range,point_max_range)
		customers_plot := IVEaddplot("Customers", IVE_BLACK)
		forall(i in CUSTOMERS_NUMBER) IVEdrawpoint(customers_plot, CUSTOMERS(i,1), CUSTOMERS(i,2));
		forall(i in CUSTOMERS_NUMBER) IVEdrawlabel(customers_plot, CUSTOMERS(i,1), CUSTOMERS(i,2), strfmt(CUSTOMERS(i,3),2));
		!forall(i in CUSTOMERS_NUMBER) IVEdrawlabel(customers_plot, CUSTOMERS(i,1), CUSTOMERS(i,2), strfmt(i,2));
	end-procedure
	
	procedure draw_edges
		IVEzoom(0,0,point_max_range,point_max_range)
		edges_plot := IVEaddplot("Edges", IVE_BLACK)
		forall(i in POINTS_NUMBER) do
			forall(j in POINTS_NUMBER) do
				if(getsol(edge_exists(i,j))=1) then
					IVEdrawline(edges_plot, POINTS(i,1), POINTS(i,2), POINTS(j,1), POINTS(j,2));
				end-if
			end-do
		end-do
		!forall(i in CUSTOMERS_NUMBER) IVEdrawlabel(customers_plot, CUSTOMERS(i,1), CUSTOMERS(i,2), strfmt(CUSTOMERS(i,3),2));
	end-procedure

end-model
