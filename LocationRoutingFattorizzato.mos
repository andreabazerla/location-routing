model "Location Routing"

  uses "mmxprs", "mmsvg"
  version 2.0.0
  setparam("XPRS_VERBOSE", false)

	forward function Connessi:integer
	forward procedure azzera_visto
	forward procedure visita(n:integer)

	forward procedure draw_locations
  	forward procedure draw_customers
  	forward procedure draw_edges

  	forward procedure plot(saved:boolean)

  	declarations
    	locations_number: integer
    	customers_number: integer
    	points_number: integer
    	depots_capacity: integer
    end-declarations

    locations_number := 5
  	customers_number := 10

  	points_number := locations_number*2 + customers_number

  	depots_capacity := 15
  	customer_max_demand := 10
  	depot_max_cost := 5
  	point_max_range := 100

    POINTS_NUMBER:= 1..points_number
    LOCATIONS_START_NUMBER:= 1..locations_number
    LOCATIONS_END_NUMBER:= locations_number+1..locations_number*2
    LOCATIONS_START_END_NUMBER:= 1..locations_number*2
    CUSTOMERS_NUMBER := locations_number*2+1..points_number

    declarations
		LOCATIONS: array(LOCATIONS_START_NUMBER) of array(1..3) of integer
		LOCATIONS_START: array(LOCATIONS_START_NUMBER) of array(1..3) of integer
		LOCATIONS_END: array(LOCATIONS_END_NUMBER) of array(1..3) of integer
		LOCATIONS_START_END: array(LOCATIONS_START_END_NUMBER) of array(1..3) of integer
		CUSTOMERS: array(CUSTOMERS_NUMBER) of array(1..3) of integer

		POINTS: array(POINTS_NUMBER) of array(1..3) of integer
		DISTANCES: array(POINTS_NUMBER, POINTS_NUMBER) of real
		visto: array(POINTS_NUMBER) of integer

		build_depot: array(LOCATIONS_START_END_NUMBER) of mpvar
		edge_exists: array(POINTS_NUMBER, POINTS_NUMBER) of mpvar
		customer_depot: array(CUSTOMERS_NUMBER, LOCATIONS_START_END_NUMBER) of mpvar

        VINCOLI: dynamic array(1..points_number*points_number*points_number) of linctr

		Objective: linctr
  	end-declarations

  	forall(i in LOCATIONS_START_END_NUMBER) build_depot(i) is_binary

	forall(i in POINTS_NUMBER, j in POINTS_NUMBER) edge_exists(i,j) is_binary

	forall(i in CUSTOMERS_NUMBER, j in LOCATIONS_START_END_NUMBER) customer_depot(i,j) is_binary

    !INITIALIZATION OF ARRAYS-----------------------------------------------------

	contatore := 1
  	forall(i in LOCATIONS_START_NUMBER) do
		LOCATIONS(i,1) := integer(round((point_max_range*random)))
		LOCATIONS(i,2) := integer(round((point_max_range*random)))
		LOCATIONS(i,3) := integer(round((depot_max_cost*random)+0.5))
	end-do

	forall(i in LOCATIONS_START_NUMBER) do
		LOCATIONS_START(i,1) := LOCATIONS(i,1)
		LOCATIONS_START(i,2) := LOCATIONS(i,2)
		LOCATIONS_START(i,3) := LOCATIONS(i,3)
	end-do

  	forall(i in LOCATIONS_END_NUMBER) do
  		LOCATIONS_END(i,1) := LOCATIONS(i-locations_number,1)
		LOCATIONS_END(i,2) := LOCATIONS(i-locations_number,2)
		LOCATIONS_END(i,3) := LOCATIONS(i-locations_number,3)
	end-do

  	write("\nLOCATIONS_START: [")
  	forall(i in LOCATIONS_START_NUMBER) do
  		write("[",LOCATIONS_START(i,1)," ",LOCATIONS_START(i,2)," ", LOCATIONS_START(i,3),"] ")
  	end-do
  	write("]")

  	write("\nLOCATIONS_END: [")
  	forall(i in LOCATIONS_END_NUMBER) do
  		write("[",LOCATIONS_END(i,1)," ",LOCATIONS_END(i,2)," ", LOCATIONS_END(i,3),"] ")
  	end-do
  	write("]")

  	forall(i in LOCATIONS_START_NUMBER) do
  		LOCATIONS_START_END(i,1) := LOCATIONS_START(i,1)
  		LOCATIONS_START_END(i,2) := LOCATIONS_START(i,2)
  		LOCATIONS_START_END(i,3) := LOCATIONS_START(i,3)
  	end-do

  	forall(i in LOCATIONS_END_NUMBER) do
  		LOCATIONS_START_END(i,1) := LOCATIONS_END(i,1)
  		LOCATIONS_START_END(i,2) := LOCATIONS_END(i,2)
  		LOCATIONS_START_END(i,3) := LOCATIONS_END(i,3)
  	end-do

  	forall(i in CUSTOMERS_NUMBER) do
		CUSTOMERS(i,1) := integer(round((point_max_range*random)))
		CUSTOMERS(i,2) := integer(round((point_max_range*random)))
		CUSTOMERS(i,3) := integer(round((customer_max_demand*random)+0.5))
  	end-do

 	write("\nCUSTOMERS: [")
  	forall(i in CUSTOMERS_NUMBER) do
  		write("[",CUSTOMERS(i,1)," ",CUSTOMERS(i,2)," ", CUSTOMERS(i,3),"] ")
  	end-do
  	write("]")

	forall(i in LOCATIONS_START_NUMBER) do
		POINTS(i,1) := LOCATIONS(i,1)
		POINTS(i,2) := LOCATIONS(i,2)
		POINTS(i,3) := LOCATIONS(i,3)

		POINTS(i+locations_number,1) := LOCATIONS(i,1)
		POINTS(i+locations_number,2) := LOCATIONS(i,2)
		POINTS(i+locations_number,3) := LOCATIONS(i,3)

	end-do

	forall(i in CUSTOMERS_NUMBER) do
		POINTS(i,1) := CUSTOMERS(i,1)
		POINTS(i,2) := CUSTOMERS(i,2)
		POINTS(i,3) := CUSTOMERS(i,3)
	end-do

 	write("\nPOINTS: [")
  	forall(i in POINTS_NUMBER) do
  		write("[",POINTS(i,1)," ",POINTS(i,2)," ", POINTS(i,3),"] ")
  	end-do
  	writeln("]")

  	writeln('')
	forall(i in POINTS_NUMBER) do
		forall(j in POINTS_NUMBER) do
			if (i<=locations_number*2 and j<=locations_number*2) then
				DISTANCE(i,j) := 0.0
			else
				DISTANCE(i,j) := sqrt((POINTS(j,1)-POINTS(i,1))^2 + (POINTS(j,2)-POINTS(i,2))^2)
			end-if
			write(strfmt(DISTANCE(i,j), 2, 2), "\t")
		end-do
		write("\n")
	end-do

	!VINCOLI DEL MODELLO-----------------------------------------------------------

	!Ogni cliente appartiene a un magazzino start
	forall(i in CUSTOMERS_NUMBER)
		sum(j in LOCATIONS_START_NUMBER) customer_depot(i,j) = 1

	! Vincolo di capacita'
	forall(j in LOCATIONS_START_NUMBER)
		sum(i in CUSTOMERS_NUMBER) (CUSTOMERS(i,3) * customer_depot(i,j)) <= depots_capacity

    !Se un magazzino è aperto, allora il cliente può appartenere a quel magazzino
	forall(i in CUSTOMERS_NUMBER, j in LOCATIONS_START_NUMBER)
		 build_depot(j) >= customer_depot(i,j)

	! No archi su loro stessi
	sum(i in POINTS_NUMBER, j in POINTS_NUMBER | i=j) edge_exists(i,j) = 0

	! Per ogni nodo si ha uno ed uno solo arco entrante ed uscente
	forall(i in POINTS_NUMBER) do
		sum(j in POINTS_NUMBER) edge_exists(i,j) = 1
		sum(j in POINTS_NUMBER) edge_exists(j,i) = 1
	end-do

	! Dopo un magazzino end ci deve essere un arco verso un magazzino start diverso da se stesso
	forall(i in LOCATIONS_END_NUMBER)
		sum(j in LOCATIONS_START_NUMBER | (i-locations_number)<>j) edge_exists(i,j) = 1

	! Dopo ogni magazzino start aperto ci deve essere un cliente
	forall(i in LOCATIONS_START_NUMBER)
		sum(j in CUSTOMERS_NUMBER) edge_exists(i,j) = build_depot(i)

	! Ogni cliente che appartiene ad un magazzino aperto puo' avere un arco che dal magazzino arriva a lui stesso
	!Qui si ragiona per l'arco che va dal magazzino start al cliente
	forall(i in CUSTOMERS_NUMBER, j in LOCATIONS_START_NUMBER)
		edge_exists(j,i) <= customer_depot(i,j)

	! Ogni cliente che appartiene ad un magazzino aperto puo' avere un arco che da lui stesso arriva al magazzino
	!Qui si ragiona per l'arco che da cliente va a magazzino end
	forall(i in CUSTOMERS_NUMBER, j in LOCATIONS_END_NUMBER)
		edge_exists(i,j) <= customer_depot(i,j)

	! Ogni magazzino end se costruito viene raggiunto solo da un cliente
	forall(j in LOCATIONS_END_NUMBER)
		sum(i in CUSTOMERS_NUMBER) edge_exists(i,j) = build_depot(j)

	! Se un magazzino di start e' aperto allora lo e' anche il suo end
	forall(i in LOCATIONS_START_NUMBER)
		build_depot(i+locations_number) = build_depot(i)

	! Ogni coppia di nodi e' connessa da un solo arco
	forall(i in POINTS_NUMBER, j in POINTS_NUMBER | i<>j)
		(edge_exists(i,j) + edge_exists(j,i)) <= 1

	! Dopo un cliente non deve esserci un magazzino start
	forall(i in CUSTOMERS_NUMBER)
		sum(j in LOCATIONS_START_NUMBER) edge_exists(i,j) = 0

	!Se un cliente appartiene a un magazzino di start, allora appartiene anche al magazzino end associato
	!  ->VA  ma crea dei magazzini fasulli a 0!!
	! Ciclo sui magazzini start e li associo a magazzino end
	forall(j in LOCATIONS_START_NUMBER, i in CUSTOMERS_NUMBER)
		customer_depot(i,j) = customer_depot(i, j+locations_number)

	!almeno un magazzino deve essere aperto se ci sono clienti
	if (customers_number>0) then
		sum(i in LOCATIONS_START_NUMBER) build_depot(i) >=1
	end-if

	! la somma delle domande di tutti i clienti deve essere minore uguale della capacità dei magazzini moltiplicata per il numero di possibili magazzini
	sum(i in CUSTOMERS_NUMBER) CUSTOMERS(i,3) <= sum(j in LOCATIONS_START_NUMBER) depots_capacity*build_depot(j)


    writeln(sum(i in CUSTOMERS_NUMBER) CUSTOMERS(i,3))
	writeln(depots_capacity*locations_number)

!FUNZIONE OBIETTIVO------------------------------------------------------------

  	Objective := sum(i in LOCATIONS_START_NUMBER) (LOCATIONS(i,3) * build_depot(i)) + sum(i in POINTS_NUMBER, j in POINTS_NUMBER) (DISTANCE(i,j) * edge_exists(i,j))

	minimize(Objective)
	writeln("\nObjective = ", getobjval, "\n")

	plot(false)

	!azzera visto azzera le visite su tutti i punti
	azzera_visto

	! Per ogni magazzino start, se il magazzino è stato costruito allora fai una visita
	forall(i in LOCATIONS_START_NUMBER) do
		if(getsol(build_depot(i))=1) then
			visita(i)
			break
		end-if
	end-do

	iter := 0
	n_nodi := points_number
	while(Connessi < n_nodi) do

	    !la somma degli archi da un nodo a tutti gli altri nodi dello stesso magazzino deve essere 1
	    (!contatore := 1
	    forall(k in LOCATIONS_START_NUMBER)
	        if(getsol(build_depot(k)) = 1) then
	            forall(i in CUSTOMERS_NUMBER) do
	                create(VINCOLI(contatore))
	                VINCOLI(contatore) := sum(j in CUSTOMERS_NUMBER) edge_exists(i,j) = 1
	                contatore +=1
	            end-do
	       end-if


        !la somma degli archi da un nodo a tutti gli altri nodi degli altri magazzini deve essere 0
        forall(k in LOCATIONS_START_NUMBER |getsol(build_depot(k)) = 1)
            forall(i in LOCATIONS_START_NUMBER|i<>k)
                forall(j in CUSTOMERS_NUMBER | getsol(customer_depot(j,k)) = 1)do
                    create(VINCOLI(contatore))
                    VINCOLI(contatore) := sum(l in CUSTOMERS_NUMBER | getsol(customer_depot(l,i)) = 1) edge_exists(j,l) = 0
                    contatore+=1
                end-do
        !)
		! Vincolo di CutSet


		! TO-DO: se un cliente appartiene ad un magazzino ed è connesso direttamente al magazzino allora il cliente
		! successivo dovrà appartenere anche lui al magazzino
		(!contatore := 1
		forall(k in LOCATIONS_START_NUMBER)
			forall(i in CUSTOMERS_NUMBER)
				forall(j in CUSTOMERS_NUMBER | i<>j) do
					if((getsol(customer_depot(i,k)) + getsol(customer_depot(j,k))) = 1) then
						VINCOLI(contatore) := edge_exists(i,j) = 0  !se due clienti appartengono a diversi magazzini allora non sono direttamente collegati
					elif((getsol(customer_depot(i,k)) + getsol(customer_depot(j,k))) = 2) then
						VINCOLI(contatore) := edge_exists(i,j) <= 1
					end-if
					contatore += 1
				end-do!)

        sum(i,j in POINTS_NUMBER | (visto(i)+visto(j)=1)) edge_exists(i,j) >= 2
		iter := iter + 1
		minimize(Objective)
		writeln(iter, "\nObjective = ", getobjval)

		writeln("\nbuild_depot(i)")
		forall(i in LOCATIONS_START_NUMBER) do
			write(getsol(build_depot(i)))
			write(' ')
		end-do
		writeln('')
		forall(i in LOCATIONS_END_NUMBER) do
			write(getsol(build_depot(i)))
			write(' ')
		end-do

		writeln("\n\nedge_exists(i,j)")
		forall(i in POINTS_NUMBER) do
			forall(j in POINTS_NUMBER) do
				write(getsol(edge_exists(i,j)))
				write(" ")
			end-do
			writeln("")
		end-do

		azzera_visto

		forall(i in LOCATIONS_START_NUMBER) do
			if(getsol(build_depot(i))=1) then
				visita(i)
				break
			end-if
		end-do

		plot(false)
	end-do

!STAMPE---------------------------

	! Magazzini
	writeln("\nbuild_depot(i)")
	forall(i in LOCATIONS_START_NUMBER) do
		write(getsol(build_depot(i)))
		write(' ')
	end-do
	writeln('')
	forall(i in LOCATIONS_END_NUMBER) do
		write(getsol(build_depot(i)))
		write(' ')
	end-do

	! Customers-Depots
	writeln("\n\ncustomer_depot(i,j)")
	writeln('Next index: ', locations_number*2+1)
	forall(i in CUSTOMERS_NUMBER) do
		forall(j in LOCATIONS_START_END_NUMBER) do
			write(getsol(customer_depot(i,j)))
			write(' ')
		end-do
		writeln('')
	end-do

	! Archi
	writeln("\nedge_exists(i,j)")
	forall(i in POINTS_NUMBER) do
		forall(j in POINTS_NUMBER) do
			write(getsol(edge_exists(i,j)))
			write(' ')
		end-do
		writeln('')
	end-do

	plot(true)


!FUNZIONI---------------------------------------------------------------------

	function Connessi:integer
		returned := sum(i in POINTS_NUMBER) visto(i)
	end-function
!PROCEDURE--------------------------------------------------------------------

	procedure azzera_visto
		forall(i in POINTS_NUMBER)
			visto(i) := 0
	end-procedure

	procedure visita(n:integer)
		if(visto(n)<>1) then ! Se il nodo dove siamo posizionati non è stato visto...
			visto(n) := 1 !...allora lo pongo come visto.
			forall(m in POINTS_NUMBER | n<>m and round(getsol(edge_exists(n,m)))<>0) do ! Mi sposto al nodo successivo collegato dall'arco orientato
				visita(m) ! Visito il nodo in cui mi sono spostato
			end-do
		end-if
	end-procedure

	procedure draw_locations
		svgaddgroup("locations_points", "Locations Points")
		svgaddgroup("locations_cost", "Locations Cost")
		svgaddgroup("locations_index", "Locations Index")

		forall(i in LOCATIONS_START_NUMBER) do
			svgaddpoint("locations_points", LOCATIONS(i,1), LOCATIONS(i,2));
			svgsetstyle("locations_points", SVG_COLOR, SVG_RED)
		end-do

		forall(i in LOCATIONS_START_NUMBER) do
			svgaddtext("locations_cost", LOCATIONS(i,1)+1, LOCATIONS(i,2)+1, strfmt(LOCATIONS(i,3),2));
			svgsetstyle("locations_cost", SVG_FONTSIZE, "3pt")
			svgsetstyle("locations_cost", SVG_FONTWEIGHT, "bold")
			svgsetstyle("locations_cost", SVG_COLOR, SVG_BLUE)
		end-do

		forall(i in LOCATIONS_START_NUMBER) do
			multiple_index := strfmt(i,1) + "-" + strfmt(i+locations_number,1)
			svgaddtext("locations_index", LOCATIONS(i,1)+2, LOCATIONS(i,2)-2, strfmt(multiple_index,2));
			svgsetstyle("locations_index", SVG_FONTSIZE, "2pt")
			svgsetstyle("locations_index", SVG_COLOR, SVG_MAGENTA)
		end-do
	end-procedure

	procedure draw_customers
		svgaddgroup("customers_points", "Customers Points")
		svgaddgroup("customers_demand", "Customers Demand")
		svgaddgroup("customers_index", "Customers Index")

		forall(i in CUSTOMERS_NUMBER) do
			svgaddpoint("customers_points", CUSTOMERS(i,1), CUSTOMERS(i,2));
			svgsetstyle("customers_points", SVG_COLOR, SVG_YELLOW)
		end-do

		forall(i in CUSTOMERS_NUMBER) do
			svgaddtext("customers_demand", CUSTOMERS(i,1)+1, CUSTOMERS(i,2)+1, strfmt(CUSTOMERS(i,3),2));
			svgsetstyle("customers_demand", SVG_FONTSIZE, "3pt")
			svgsetstyle("customers_demand", SVG_FONTWEIGHT, "bold")
			svgsetstyle("customers_demand", SVG_COLOR, SVG_BLUE)
		end-do

		forall(i in CUSTOMERS_NUMBER) do
			svgaddtext("customers_index", CUSTOMERS(i,1)+2, CUSTOMERS(i,2)-2, strfmt(i,2));
			svgsetstyle("customers_index", SVG_FONTSIZE, "2pt")
			svgsetstyle("customers_index", SVG_COLOR, SVG_MAGENTA)
		end-do
	end-procedure

	procedure draw_edges
		svgaddgroup("edges_customers", "Edges Customers", SVG_BLACK)
		svgaddgroup("edges_depots", "Edges Depots", SVG_LIME)
		forall(i in POINTS_NUMBER, j in POINTS_NUMBER) do
			if (getsol(edge_exists(i,j))=1) then
				!gli archi verdi sono quelli tra magazzino E e mag S, quelli tra mag S e S, quelli tra E e E e quelli tra E e S
				!if (not(j<=locations_number and i>locations_number and i<=(locations_number*2))) then
				if(j<=(locations_number*2) and i<=(locations_number*2)) then
					svgaddarrow("edges_depots", POINTS(i,1), POINTS(i,2), POINTS(j,1), POINTS(j,2));
					svgsetstyle("edges_depots", SVG_STROKEWIDTH, "0.02rem")
				else
					svgaddarrow("edges_customers", POINTS(i,1), POINTS(i,2), POINTS(j,1), POINTS(j,2)); !da magazzino a cliente e da cliente a magazzino
					svgsetstyle("edges_customers", SVG_STROKEWIDTH, "0.02rem")
				end-if
			end-if
		end-do
	end-procedure

	procedure plot(saved:boolean)
		svgerase

	  	draw_locations
	  	draw_customers
	  	draw_edges

	  	svgsetgraphviewbox(-10, -10, point_max_range+20, point_max_range+20)

	  	svgsetgraphlabels("x", "y")

		if(saved) then
	  		svgsave("graph.svg")
	  		svgrefresh
	  		! svgwaitclose
	  	else
	  		svgrefresh
	  		!wait(1)
	  		svgpause
	  	end-if

	end-procedure




end-model
