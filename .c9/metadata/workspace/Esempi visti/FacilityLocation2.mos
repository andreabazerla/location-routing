{"changed":false,"filter":false,"title":"FacilityLocation2.mos","tooltip":"/Esempi visti/FacilityLocation2.mos","value":"model FacilityLocationAleLuana\r\nuses \"mmxprs\"; !gain access to the Xpress-Optimizer solver\r\n\r\ndeclarations\r\n\tn: integer !numero di localit� J\r\n\tm: integer !numero di clienti I\r\n\tk: integer !numero di magazzini aperti k\r\n\tbigM: integer !costo di apertura uguale per tutti che andr� moltiplicato per un numero randomico in base alla posizione\r\n\tcosto_s: integer !costo di servizio uguale per tutti da moltiplicare per un random\r\n\t!bigM e costo_s vanno fatti perch� la funzione random restituisce un numero tra 0 e 1\r\nend-declarations\r\n\r\nn:= 16\r\nm:= 50\r\nbigM:=1000\r\ncosto_s := 500\r\nk:= floor(n/5) !prendo un quinto delle localit� e ci faccio il floor, questi sono i magazzini che devono essere aperti\r\n\r\ndeclarations\t\r\n\tLOCALITA = 1..n\r\n\tCLIENTI = 1..m\r\n\tCOSTO_SERVIZIO: array(LOCALITA, CLIENTI) of real !sarebbe il cij dell'esempio su slide\r\n\tCOSTO_FISSO: array(LOCALITA) of real !costo di apertura di ogni localit�\r\n\tX: array(CLIENTI, LOCALITA) of mpvar !indica se il cliente � legato al magazzino\r\n\tY: array(LOCALITA) of mpvar !indica se il magazzino � aperto\r\n\tObjective: linctr\r\nend-declarations\r\n\r\n!rendiamo noti i costi fissi\r\nforall(j in LOCALITA)\r\n\tCOSTO_FISSO(j) := real(floor(bigM*random)) \r\n\r\n!rendiamo nodi i costi di servizio\r\nforall(i in CLIENTI, j in LOCALITA)\r\n\tCOSTO_SERVIZIO(j, i) := real(floor(costo_s*random))\r\n\t\r\n!dichiariamo il fatto che gli mpvar sono binari\r\nforall(i in CLIENTI, j in LOCALITA) \r\n\tX(i,j) is_binary\r\n\t\r\nforall(j in LOCALITA)\r\n\tY(j) is_binary\r\n\r\n!scrivo il modello\r\nsum(j in LOCALITA)Y(j) = k !vincolo di cardinalit�\r\n\r\nforall(j in LOCALITA) !vincolo aggregato di consistenza logica\r\n\tsum(i in CLIENTI) X(i,j) <= m*Y(j) !se un magazzino � aperto il numero di clienti posseduti dal magazzino deve essere minore di m\r\n\r\nforall(i in CLIENTI) !vincolo di semiassegnamento\r\n\tsum(j in LOCALITA) X(i,j) = 1 !ogni cliente appartiene a un solo magazzino aperto\r\n\t\r\nObjective := sum(j in LOCALITA)COSTO_FISSO(j)*Y(j) + \r\n\t\t\t sum(i in CLIENTI, j in LOCALITA)COSTO_SERVIZIO(j,i)*X(i,j)\r\n\r\nminimize(Objective) !risolve il problema intero (a variabili intere), trovando un upper bound\r\nwriteln(\"Soluzione intera \",getobjval)\r\n\r\n\r\nminimize(XPRS_LIN, Objective) !funzione obiettivo con il rilassamento continuo, bound migliore\r\nwriteln(\"Con rilassamento continuo: \", getobjval)\r\n\r\nwriteln(\"Y\")\r\nforall(j in LOCALITA | getsol(Y(j))>0 and getsol(Y(j))<=1) do !per ogni localit� tale che getsol(Y) sia positivo e minore di 1\r\n\twriteln(\"Y(\",j,\")= \",strfmt(getsol(Y(j)),2,2))\r\n\twrite(\"x frazionarie per facility \",j,\":\\t\")\t\r\n\tforall(i in CLIENTI| getsol(X(i,j))>0 and getsol(X(i,j))<=1) \r\n\t\twrite(i,\"):\", strfmt(getsol(X(i,j)),2,2),\" \" )\r\n\twrite(\"\\n\")\r\n\tend-do\r\nwriteln(\"Vincoli x>y violati:\")\r\nforall(j in LOCALITA, i in CLIENTI) do\r\n\tif (getsol(X(i,j))>getsol(Y(j)))\r\n\t\tthen\r\n\t\twriteln(i,\",\",j,\": \",\r\n\t\t\tstrfmt(getsol(X(i,j)),2,2),\">\",\r\n\t\t\tstrfmt(getsol(Y(j)),2,2))\r\n\tend-if\r\nend-do\r\n\r\ndeclarations\r\n\tCutGen: boolean\r\n\titer: integer\r\n\tMyCuts: array(range) of linctr\r\nend-declarations\r\n\r\niter :=0 ! iteration counter\r\nrepeat\r\n\tCutGen := false\r\n\titer +=1\r\n\tforall(j in LOCALITA, i in CLIENTI) do\r\n\t\tif (getsol(X(i,j))>getsol(Y(j))) ! trovato vincolo violato\r\n\t\t\tthen\r\n\t\t\tCutGen := true\r\n\t\t\twriteln(\"(\",i,\",\",j,\"): \",\r\n\t\t\t\tstrfmt(getsol(X(i,j)),2,2),\">\",\r\n\t\t\t\tstrfmt(getsol(Y(j)),2,2))\r\n\t\t\tMyCuts(iter) := X(i,j) <= Y(j)\r\n\t\tend-if\r\n\t\tif \tCutGen then\r\n\t\t\tminimize(XPRS_LIN,Objective)\r\n\t\t\twriteln(\"iter \",iter,\"): \",strfmt(getobjval,5,1))\r\n\t\t\tbreak ! esce dal loop + interno in cui si trova, esce dal forall e resta nel while\r\n\t\tend-if\r\n\tend-do\r\nuntil not(CutGen)\r\n\r\n\r\n\r\nwriteln(\"Y\")\r\nforall(j in LOCALITA| getsol(Y(j))=1.0) do \r\n\twriteln(\"Y(\",j,\")= \",strfmt(getsol(Y(j)),2,2))\r\n\twrite(\"x frazionarie per facility \",j,\":\\t\")\t\r\n\tforall(i in CLIENTI | getsol(X(i,j)) = 1.0) \r\n\t\twrite(i,\"):\", strfmt(getsol(X(i,j)),2,2),\" \" )\r\n\twrite(\"\\n\")\r\nend-do\r\n\r\n\r\nwriteln(\"generati \", 100*iter/(m*n),\"% dei vincoli possibili\\n\")\r\n! non � detto che si arrivi alla soluzione ottima intera con i tagli perch� ad \r\n! un certo punto non � pi� efficace - come detto dalle slide\r\n! soluzione intera\r\nminimize(Objective)\r\nwriteln(\"ottimo intero:\", getobjval,\"\\n\")\r\n\r\n\r\nwriteln(\"-------------------------------------------\")\r\nforall(j in LOCALITA| getsol(Y(j))=1.0) do \r\n\twriteln(\"Y(\",j,\")= \",strfmt(getsol(Y(j)),2,2))\r\n\twrite(\"x frazionarie per facility \",j,\":\\t\")\t\r\n\tforall(i in CLIENTI | getsol(X(i,j)) = 1.0) \r\n\t\twrite(i,\"):\", strfmt(getsol(X(i,j)),2,2),\" \" )\r\n\twrite(\"\\n\")\r\nend-do\r\n\r\nend-model\r\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":22,"column":26},"end":{"row":22,"column":26},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1652390964440}